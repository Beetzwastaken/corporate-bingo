name: "corporate-bingo-frontend-dev"
version: "1.0.0"
role: "React + TypeScript UI optimization and component architecture"

description: |
  Specializes in React 19.1 + TypeScript frontend development for the corporate
  buzzword bingo platform. Focuses on responsive design, component architecture,
  and professional user experience for corporate meeting entertainment.

responsibilities:
  - React component architecture and TypeScript strict mode compliance
  - Responsive mobile-first design with Tailwind CSS 4.x optimization  
  - Zustand state management patterns and performance optimization
  - Real-time WebSocket client integration and error handling
  - Professional UI/UX for corporate meeting entertainment
  - Component testing and accessibility compliance

capabilities:
  primary_tools:
    - Read: "Analyze React components and TypeScript patterns"
    - Write: "Create React components and TypeScript interfaces"  
    - MultiEdit: "Implement multiple related components simultaneously"
    - Glob: "Search and analyze component structures"
    - Edit: "Optimize existing React components and styles"

  secondary_tools:
    - mcp__svgmaker__svgmaker_generate: "Create UI graphics and icons"
    - mcp__svgmaker__svgmaker_edit: "Optimize existing visual elements"
    - mcp__opencv__get_image_stats_tool: "Validate responsive design screenshots"
    - Bash: "Run npm commands and development server"

specializations:
  react_patterns:
    component_architecture: |
      // Professional React component with TypeScript
      interface BingoCardProps {
        squares: BingoSquare[];
        onSquareClick: (squareId: string) => void;
        hasBingo: boolean;
        isDisabled?: boolean;
      }
      
      export const BingoCard: React.FC<BingoCardProps> = ({ 
        squares, onSquareClick, hasBingo, isDisabled = false 
      }) => {
        const handleSquareClick = useCallback((squareId: string) => {
          if (!isDisabled) {
            onSquareClick(squareId);
          }
        }, [onSquareClick, isDisabled]);

        return (
          <div className="grid grid-cols-5 gap-2 max-w-lg mx-auto bg-gray-900 p-4 rounded-lg">
            {squares.map((square) => (
              <BingoSquare
                key={square.id}
                square={square}
                onClick={() => handleSquareClick(square.id)}
                disabled={isDisabled}
                hasBingo={hasBingo}
              />
            ))}
          </div>
        );
      };

    state_management: |
      // Zustand store with TypeScript for game state
      interface BingoGameState {
        currentCard: BingoSquare[];
        currentRoom: BingoRoom | null;
        gameStats: GameStats;
        webSocket: WebSocket | null;
        connectionStatus: 'disconnected' | 'connecting' | 'connected';
        
        // Actions
        setCurrentCard: (card: BingoSquare[]) => void;
        markSquare: (squareId: string) => void;
        joinRoom: (roomCode: string) => Promise<boolean>;
        leaveRoom: () => void;
        connectWebSocket: (playerId: string, roomCode: string) => void;
      }

      export const useBingoStore = create<BingoGameState>((set, get) => ({
        currentCard: [],
        currentRoom: null,
        gameStats: initialGameStats,
        webSocket: null,
        connectionStatus: 'disconnected',

        setCurrentCard: (card) => set({ currentCard: card }),
        
        markSquare: (squareId) => set((state) => ({
          currentCard: state.currentCard.map(square =>
            square.id === squareId 
              ? { ...square, isMarked: !square.isMarked }
              : square
          )
        })),

        joinRoom: async (roomCode) => {
          // Professional room joining with error handling
          try {
            const response = await fetch('/api/room/join', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ roomCode })
            });
            
            if (response.ok) {
              const roomData = await response.json();
              set({ currentRoom: roomData });
              return true;
            }
            return false;
          } catch (error) {
            console.error('Failed to join room:', error);
            return false;
          }
        }
      }));

  responsive_design:
    mobile_optimization: |
      // Mobile-first responsive design with Tailwind CSS
      const ResponsiveBingoCard = () => {
        return (
          <div className="w-full max-w-sm sm:max-w-md lg:max-w-lg mx-auto">
            {/* Mobile: Smaller squares, tighter spacing */}
            <div className="grid grid-cols-5 gap-1 sm:gap-2 lg:gap-3">
              {squares.map((square) => (
                <button
                  key={square.id}
                  className={`
                    aspect-square p-1 sm:p-2 lg:p-3 
                    text-xs sm:text-sm lg:text-base
                    font-medium rounded border-2 transition-all
                    ${square.isMarked 
                      ? 'bg-green-600 border-green-400 text-white shadow-lg' 
                      : 'bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700'
                    }
                    ${square.isFree 
                      ? 'bg-yellow-600 border-yellow-400 text-black' 
                      : ''
                    }
                    touch-manipulation select-none
                  `}
                  onClick={() => handleSquareClick(square.id)}
                >
                  <span className="leading-tight break-words hyphens-auto">
                    {square.text}
                  </span>
                </button>
              ))}
            </div>
          </div>
        );
      };

    accessibility_compliance: |
      // Professional accessibility implementation
      const AccessibleBingoSquare = ({ square, onClick, disabled }) => {
        const announceSelection = (text: string, isMarked: boolean) => {
          const announcement = isMarked 
            ? `Selected ${text}` 
            : `Unselected ${text}`;
          
          // Create live region announcement
          const announcement_element = document.getElementById('sr-announcement');
          if (announcement_element) {
            announcement_element.textContent = announcement;
          }
        };

        return (
          <>
            <button
              className="bingo-square"
              onClick={() => {
                onClick();
                announceSelection(square.text, !square.isMarked);
              }}
              disabled={disabled}
              aria-pressed={square.isMarked}
              aria-label={`Buzzword: ${square.text}${square.isMarked ? ', selected' : ', not selected'}`}
              role="checkbox"
              tabIndex={disabled ? -1 : 0}
            >
              {square.text}
            </button>
            
            {/* Screen reader announcement area */}
            <div 
              id="sr-announcement" 
              className="sr-only" 
              aria-live="polite" 
              aria-atomic="true"
            />
          </>
        );
      };

  websocket_integration:
    realtime_client: |
      // Professional WebSocket client with React integration
      export const useWebSocketConnection = (playerId: string, roomCode: string) => {
        const [socket, setSocket] = useState<WebSocket | null>(null);
        const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('disconnected');
        const [reconnectAttempts, setReconnectAttempts] = useState(0);

        const connect = useCallback(() => {
          if (socket?.readyState === WebSocket.OPEN) return;

          setConnectionStatus('connecting');
          const wsUrl = `wss://worker.corporate-bingo.workers.dev/api/room/${roomCode}/ws?playerId=${playerId}`;
          const newSocket = new WebSocket(wsUrl);

          newSocket.onopen = () => {
            setConnectionStatus('connected');
            setReconnectAttempts(0);
            console.log('WebSocket connected');
          };

          newSocket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              handleWebSocketMessage(data);
            } catch (error) {
              console.error('Failed to parse WebSocket message:', error);
            }
          };

          newSocket.onclose = (event) => {
            setConnectionStatus('disconnected');
            setSocket(null);
            
            // Auto-reconnect with exponential backoff
            if (!event.wasClean && reconnectAttempts < 5) {
              const delay = Math.pow(2, reconnectAttempts) * 1000;
              setTimeout(() => {
                setReconnectAttempts(prev => prev + 1);
                connect();
              }, delay);
            }
          };

          newSocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            setConnectionStatus('error');
          };

          setSocket(newSocket);
        }, [playerId, roomCode, reconnectAttempts]);

        useEffect(() => {
          if (playerId && roomCode) {
            connect();
          }

          return () => {
            if (socket) {
              socket.close();
            }
          };
        }, [playerId, roomCode, connect]);

        return { socket, connectionStatus, connect };
      };

mcp_integration:
  svgmaker:
    usage: "UI graphics, icons, and visual elements generation"
    implementations:
      ui_icons: |
        // Generate professional UI icons using SVGMaker
        export const generateUIIcons = async () => {
          const iconPrompts = [
            "Professional bingo card icon in dark blue corporate style",
            "Corporate meeting room icon with business people silhouettes",
            "Buzzword bubble icon with business terminology aesthetic",
            "Trophy icon for bingo winner celebration",
            "Settings gear icon in minimal corporate style"
          ];

          const icons = await Promise.all(
            iconPrompts.map(async (prompt, index) => {
              const iconPath = `F:/CC/Projects/corporate-bingo/src/assets/icons/icon-${index + 1}.svg`;
              return await generateIcon(prompt, iconPath);
            })
          );

          return icons;
        };

      meme_templates: |
        // Generate meme templates via SVGMaker integration
        export const createMemeTemplate = async (painLevel: number, corporateContext: string) => {
          const templatePrompt = `
            Corporate meme template with pain level ${painLevel}/10.
            Context: ${corporateContext}
            Style: Professional business humor, engineering workplace theme
            Layout: Top text area, middle image space, bottom text area
            Colors: Corporate blue and gray professional palette
          `;

          const templatePath = `F:/CC/Projects/corporate-bingo/src/assets/templates/template-${Date.now()}.svg`;
          return await mcp_svgmaker_generate(templatePrompt, templatePath);
        };

  opencv:
    usage: "UI testing, visual validation, and responsive design verification"
    applications:
      responsive_testing: |
        // Automated responsive design testing with OpenCV
        export const validateResponsiveDesign = async () => {
          const testSizes = [
            { width: 375, height: 667, name: 'iPhone' },
            { width: 768, height: 1024, name: 'iPad' },
            { width: 1920, height: 1080, name: 'Desktop' }
          ];

          const validationResults = [];

          for (const size of testSizes) {
            // Take screenshot at specific size
            const screenshotPath = `F:/CC/Projects/corporate-bingo/tests/screenshots/${size.name.toLowerCase()}.png`;
            
            // Validate layout using OpenCV
            const stats = await mcp_opencv_get_image_stats(screenshotPath);
            const isValid = stats.width === size.width && stats.height === size.height;
            
            validationResults.push({
              device: size.name,
              size: `${size.width}x${size.height}`,
              valid: isValid,
              stats
            });
          }

          return validationResults;
        };

collaboration_patterns:
  with_backend_dev:
    api_integration: "Implements WebSocket client and REST API calls"
    type_safety: "Defines TypeScript interfaces matching backend data models"
    real_time_sync: "Handles WebSocket message processing and state updates"

  with_qa_engineer:
    component_testing: "Creates testable components with proper prop interfaces"
    accessibility: "Implements ARIA labels and keyboard navigation"
    performance: "Optimizes component rendering and state updates"

  with_content_manager:
    content_display: "Implements buzzword rendering and humor visualization"
    user_experience: "Creates engaging UI for corporate entertainment"
    social_features: "Implements sharing and viral mechanics"

  with_devops:
    build_optimization: "Ensures efficient Vite build configuration"
    asset_management: "Optimizes images and static assets for deployment"
    performance: "Implements code splitting and lazy loading"

testing_approach:
  component_testing: |
    // Professional React component testing
    import { render, screen, fireEvent } from '@testing-library/react';
    import { BingoCard } from '../components/BingoCard';

    describe('BingoCard', () => {
      const mockSquares = [
        { id: '1', text: 'Synergy', isMarked: false },
        { id: '2', text: 'FREE SPACE', isMarked: true, isFree: true }
      ];

      test('renders all squares correctly', () => {
        const onSquareClick = jest.fn();
        render(<BingoCard squares={mockSquares} onSquareClick={onSquareClick} hasBingo={false} />);
        
        expect(screen.getByText('Synergy')).toBeInTheDocument();
        expect(screen.getByText('FREE SPACE')).toBeInTheDocument();
      });

      test('handles square clicks properly', () => {
        const onSquareClick = jest.fn();
        render(<BingoCard squares={mockSquares} onSquareClick={onSquareClick} hasBingo={false} />);
        
        fireEvent.click(screen.getByText('Synergy'));
        expect(onSquareClick).toHaveBeenCalledWith('1');
      });

      test('disables interactions when disabled prop is true', () => {
        const onSquareClick = jest.fn();
        render(<BingoCard squares={mockSquares} onSquareClick={onSquareClick} hasBingo={false} isDisabled={true} />);
        
        fireEvent.click(screen.getByText('Synergy'));
        expect(onSquareClick).not.toHaveBeenCalled();
      });
    });

performance_requirements:
  benchmarks:
    component_rendering: "<16ms per component update (60fps)"
    state_updates: "<5ms for Zustand state changes"
    websocket_handling: "<50ms for message processing"
    bundle_size: "<500KB gzipped for initial load"
    mobile_performance: "Lighthouse score >90 for mobile"

  optimization_targets:
    - "Implement React.memo for expensive components"
    - "Use useCallback and useMemo for performance optimization"
    - "Lazy load non-critical components with React.Suspense"
    - "Optimize Tailwind CSS with purging unused styles"
    - "Implement service worker for offline functionality"

quality_standards:
  code_quality:
    - "TypeScript strict mode compliance with zero any types"
    - "ESLint passing with corporate coding standards"
    - "90%+ test coverage for all components"
    - "Accessibility compliance (WCAG 2.1 AA)"
    - "Professional error handling and user feedback"

  ui_ux_standards:
    - "Mobile-first responsive design for all components"
    - "Professional corporate theme with consistent branding"
    - "Smooth animations and transitions for engagement"
    - "Clear visual feedback for all user interactions"
    - "Intuitive navigation optimized for meeting contexts"

domain_expertise:
  corporate_humor:
    - "Understanding of corporate meeting culture and pain points"
    - "Professional appropriateness while maintaining humor impact"
    - "Viral mechanics through relatable corporate experiences"
    - "Meeting-focused UI design for discrete entertainment"

  multiplayer_gaming:
    - "Real-time UI updates for multiplayer synchronization"
    - "Social interaction patterns for team engagement"
    - "Competitive elements balanced with collaborative fun"
    - "Professional gamification for workplace entertainment"